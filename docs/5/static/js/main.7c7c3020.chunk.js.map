{"version":3,"sources":["components/App.tsx","serviceWorker.ts","index.tsx"],"names":["initialValue","type","children","text","runCommand","name","editor","args","console","log","Editor","App","useMemo","withReact","createEditor","useState","filterBy","setFilterBy","lastResult","setLastResult","pendingValue","setPendingValue","value","setValue","methods","reduce","memo","method","arg","methodState","setMethodState","useEffect","JSON","stringify","undefined","result","filterByLower","toLowerCase","className","href","onChange","renderElement","attributes","E","element","currentTarget","onClick","parse","e","alert","placeholder","filter","indexOf","map","returnType","typeParameters","key","join","i","title","isOptional","disabled","readOnly","slice","some","a","parsed","isArgValid","buildArg","String","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.7c7c3020.chunk.js","sourcesContent":["import React, { useMemo, useState, useEffect } from 'react'\nimport { createEditor, Editor, Node } from 'slate'\nimport { Editable, Slate, withReact } from 'slate-react'\n\nimport { methods } from '../data/editor.json'\n\nconst initialValue: Node[] = [\n  {\n    type: 'div',\n    children: [\n      {\n        type: 'paragraph',\n        children: [\n          {\n            text: 'Block A1'\n          }\n        ],\n      },\n      {\n        type: 'paragraph',\n        children: [\n          {\n            text: 'Block A2'\n          }\n        ],\n      }\n    ]\n  },\n  {\n    type: 'paragraph',\n    children: [\n      {\n        text: 'Block B'\n      }\n    ]\n  },\n  {\n    type: 'paragraph',\n    children: [\n      {\n        text: 'Block C'\n      }\n    ]\n  },\n]\n\nfunction buildArg(\n  arg: (typeof methods)[0]['args'][0],\n  value: string,\n) {\n  if (arg.type === 'string') {\n    return value\n  }\n\n  let parsed\n  try {\n    parsed = JSON.parse(value)\n  }\n  catch (e) {\n    parsed = value\n  }\n\n  return value\n    ? parsed\n    : undefined\n}\n\nfunction isArgValid(\n  arg: (typeof methods)[0]['args'][0],\n  value: string,\n): boolean {\n  if (arg.type === 'string') {\n    return true\n  }\n\n  let parsed\n  try {\n    parsed = JSON.parse(value)\n  }\n  catch (e) {\n    parsed = value\n  }\n\n  return (arg.isOptional && value === '') || parsed\n}\n\nfunction resultAsString(\n  result: any\n) {\n  if (typeof result === 'undefined') {\n    return 'undefined'\n  }\n\n  if (typeof result === 'object') {\n    return JSON.stringify(result, undefined, 2)\n  }\n\n  return String(result)\n}\n\nfunction runCommand(\n  name: string,\n  editor: Editor,\n  ...args: unknown[]\n) {\n  console.log('runCommand:', name, '[editor]', ...args)\n  return (Editor as any)[name](editor, ...args)\n}\n\nconst App: React.FC = () => {\n  const editor = useMemo(\n    () => withReact(createEditor()),\n    []\n  )\n\n  const [filterBy, setFilterBy] = useState('')\n  const [lastResult, setLastResult] = useState('None')\n  const [pendingValue, setPendingValue] = useState()\n  const [value, setValue] = useState(initialValue)\n  const [methodState, setMethodState] = useState(() =>\n    methods.reduce(\n      (memo, method) => {\n        memo[method.name] = method.args.reduce((memo, arg) => {\n          memo[arg.name] = ''\n          return memo\n        }, {} as Record<string, string>)\n        return memo\n      },\n      {} as Record<string, Record<string, string>>\n    )\n  )\n\n  useEffect(\n    () => {\n      setPendingValue(\n        JSON.stringify(value, undefined, 2)\n      )\n    },\n    [value]\n  )\n\n  const filterByLower = filterBy.toLowerCase()\n\n  return (\n    <div className=\"c_app\">\n      <h1>\n        <span>SlateJS Playground</span>\n        <a href=\"../4\">0.4x</a>\n        <span>0.5x</span>\n      </h1>\n\n      <Slate\n        editor={editor}\n        onChange={setValue}\n        value={value}\n      >\n        <Editable\n          className=\"c_editor\"\n          renderElement={({ attributes, children, element }) => {\n            const E = element.type === 'paragraph'\n              ? 'p'\n              : 'div'\n\n            return (\n              <E {...attributes}>{children}</E>\n            )\n          }}\n        />\n      </Slate>\n\n      <div className=\"c_tools\">\n        <div className=\"c_value\">\n          <h2>Value</h2>\n          <textarea\n            onChange={({ currentTarget }) => {\n              setPendingValue(currentTarget.value)\n            }}\n            value={pendingValue}\n          />\n          <button onClick={() => {\n            try {\n              setValue(JSON.parse(pendingValue))\n            }\n            catch(e) {\n              alert('Value could not be parsed.')\n            }\n          }}>Update</button>\n        </div>\n\n        <div className=\"c_methods\">\n          <h2>Editor Commands</h2>\n          <input\n            className=\"c_method-filter\"\n            onChange={({ currentTarget }) => {\n              setFilterBy(currentTarget.value)\n            }}\n            placeholder=\"Filter static Editor methods...\"\n            value={filterBy}\n          />\n          <div className=\"scroll\">\n            {\n              methods\n                .filter(\n                  ({ name }) => name.toLowerCase().indexOf(filterByLower) > -1\n                ).map(\n                  ({ args, name, returnType, typeParameters }) => (\n                    <div className=\"c_method\" key={name}>\n                      <label className=\"c_method__label\">\n                        <span>Editor.{name}{typeParameters ? `<${typeParameters.join(', ')}>` : ''}(</span>\n                        {\n                          args.map(\n                            (arg, i) => (\n                              <div\n                                className=\"c_method__arg\"\n                                key={arg.name}\n                                title={`${arg.name}: ${arg.type}`}\n                              >\n                                <span\n                                  className=\"c_method__arg-label\"\n                                >{arg.name}{arg.isOptional ? '?' : ''}</span>\n\n                                <input\n                                  className=\"c_method__arg-input\"\n                                  disabled={i === 0}\n                                  onChange={({ currentTarget }) => {\n                                    setMethodState({\n                                      ...methodState,\n                                      [name]: {\n                                        ...methodState[name],\n                                        [arg.name]: currentTarget.value,\n                                      },\n                                    })\n                                  }}\n                                  placeholder={i === 0 ? '[Editor Instance]' : arg.type}\n                                  readOnly={i === 0}\n                                  value={methodState[name][arg.name]}\n                                />\n                              </div>\n                            )\n                          )\n                        }\n                        <span>): {returnType}</span>\n                      </label>\n\n                      <button\n                        disabled={args.slice(1).some(a => !isArgValid(a, methodState[name][a.name]))}\n                        onClick={() => {\n                          const result = runCommand(\n                            name,\n                            editor,\n                            ...args.slice(1).map(\n                              a => buildArg(\n                                a,\n                                methodState[name][a.name]\n                              )\n                            )\n                          )\n                          setLastResult(result)\n                          console.log('result:', JSON.stringify(result, undefined, 2))\n                        }}\n                      >Go</button>\n                    </div>\n                  ))\n            }\n          </div>\n        </div>\n\n        <div className=\"c_result\">\n          <h2>Result</h2>\n          <pre>\n            {\n              resultAsString(lastResult)\n            }\n          </pre>\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport { App } from './components';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}